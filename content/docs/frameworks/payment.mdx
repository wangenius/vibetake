---
title: æ”¯ä»˜é›†æˆ
description: ä½¿ç”¨ Stripe å®ç°æ”¯ä»˜åŠŸèƒ½
---

# Stripe æ”¯ä»˜é›†æˆæŒ‡å—

vibetake é›†æˆäº† [Stripe](https://stripe.com) æ”¯ä»˜ç³»ç»Ÿï¼Œä¸ºä½ çš„åº”ç”¨æä¾›å®Œæ•´çš„æ”¯ä»˜è§£å†³æ–¹æ¡ˆã€‚æœ¬æ–‡æ¡£å°†è¯¦ç»†ä»‹ç»å¦‚ä½•é…ç½®å’Œä½¿ç”¨ Stripe æ”¯ä»˜åŠŸèƒ½ã€‚

## æ¦‚è¿°

Stripe æ˜¯å…¨çƒé¢†å…ˆçš„åœ¨çº¿æ”¯ä»˜å¤„ç†å¹³å°ï¼Œæä¾›å®‰å…¨ã€å¯é çš„æ”¯ä»˜åŸºç¡€è®¾æ–½ã€‚vibetake çš„ Stripe é›†æˆæ”¯æŒå¤šç§æ”¯ä»˜åœºæ™¯å’Œä¸šåŠ¡æ¨¡å¼ã€‚

### æ ¸å¿ƒç‰¹æ€§

- ğŸ’³ **å¤šç§æ”¯ä»˜æ–¹å¼** - ä¿¡ç”¨å¡ã€å€Ÿè®°å¡ã€æ•°å­—é’±åŒ…ç­‰
- ğŸ”„ **è®¢é˜…ç®¡ç†** - çµæ´»çš„è®¢é˜…è®¡è´¹å’Œç®¡ç†
- ğŸ“Š **æ”¯ä»˜åˆ†æ** - è¯¦ç»†çš„äº¤æ˜“æ•°æ®å’ŒæŠ¥å‘Š
- ğŸ”’ **å®‰å…¨åˆè§„** - PCI DSS åˆè§„ï¼Œæ•°æ®åŠ å¯†ä¿æŠ¤
- ğŸŒ **å…¨çƒæ”¯æŒ** - æ”¯æŒ135+ç§è´§å¸å’Œ45+ä¸ªå›½å®¶
- ğŸ¯ **æ™ºèƒ½è·¯ç”±** - ä¼˜åŒ–æ”¯ä»˜æˆåŠŸç‡å’Œæˆæœ¬
- ğŸ“± **ç§»åŠ¨ä¼˜åŒ–** - å“åº”å¼æ”¯ä»˜ç•Œé¢
- ğŸ”§ **å¼ºå¤§ API** - çµæ´»çš„é›†æˆå’Œè‡ªå®šä¹‰

## ç³»ç»Ÿæ¶æ„

```mermaid
graph TB
    A[å®¢æˆ·ç«¯] --> B[æ”¯ä»˜ç»„ä»¶]
    B --> C[Checkout Session]
    C --> D[Stripe Dashboard]
    D --> E[Webhook]
    E --> F[åç«¯å¤„ç†]
    F --> G[æ•°æ®åº“æ›´æ–°]
    
    subgraph "æ”¯ä»˜æµç¨‹"
        H[ç”¨æˆ·é€‰æ‹©å•†å“] --> I[åˆ›å»ºæ”¯ä»˜ä¼šè¯]
        I --> J[è·³è½¬ Stripe]
        J --> K[å®Œæˆæ”¯ä»˜]
        K --> L[Webhook é€šçŸ¥]
        L --> M[è®¢å•ç¡®è®¤]
    end
    
    subgraph "è®¢é˜…æµç¨‹"
        N[é€‰æ‹©è®¢é˜…è®¡åˆ’] --> O[åˆ›å»ºå®¢æˆ·]
        O --> P[åˆ›å»ºè®¢é˜…]
        P --> Q[å®šæœŸæ‰£è´¹]
        Q --> R[çŠ¶æ€åŒæ­¥]
    end
```

## å®‰è£…å’Œé…ç½®

### 1. å®‰è£…ä¾èµ–

```bash
# å®‰è£… Stripe ç›¸å…³åŒ…
npm install stripe @stripe/stripe-js @stripe/react-stripe-js

# å®‰è£…ç±»å‹å®šä¹‰ï¼ˆå¦‚æœä½¿ç”¨ TypeScriptï¼‰
npm install --save-dev @types/stripe
```

### 2. ç¯å¢ƒå˜é‡é…ç½®

åœ¨ `.env.local` æ–‡ä»¶ä¸­é…ç½® Stripe å¯†é’¥ï¼š

```bash
# Stripe é…ç½®
STRIPE_SECRET_KEY=sk_test_51...  # æœåŠ¡ç«¯å¯†é’¥ï¼ˆæµ‹è¯•ç¯å¢ƒï¼‰
NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_test_51...  # å®¢æˆ·ç«¯å¯†é’¥ï¼ˆæµ‹è¯•ç¯å¢ƒï¼‰
STRIPE_WEBHOOK_SECRET=whsec_...  # Webhook ç­¾åå¯†é’¥

# ç”Ÿäº§ç¯å¢ƒé…ç½®
# STRIPE_SECRET_KEY=sk_live_51...
# NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY=pk_live_51...

# åº”ç”¨é…ç½®
NEXT_PUBLIC_APP_URL=http://localhost:3000  # åº”ç”¨åŸºç¡€ URL
```

### 3. åˆ›å»º Stripe æœåŠ¡

```typescript
// src/services/payment/stripe-config.ts
import Stripe from 'stripe';

if (!process.env.STRIPE_SECRET_KEY) {
  throw new Error('STRIPE_SECRET_KEY is not set in environment variables');
}

export const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, {
  apiVersion: '2024-06-20',
  typescript: true,
});

// Stripe é…ç½®å¸¸é‡
export const STRIPE_CONFIG = {
  currency: 'usd', // é»˜è®¤è´§å¸
  successUrl: `${process.env.NEXT_PUBLIC_APP_URL}/payment/success`,
  cancelUrl: `${process.env.NEXT_PUBLIC_APP_URL}/payment/cancel`,
  webhookEndpoint: `${process.env.NEXT_PUBLIC_APP_URL}/api/payment/webhooks/stripe`,
} as const;

// æ”¯æŒçš„æ”¯ä»˜æ–¹å¼
export const PAYMENT_METHODS = [
  'card',
  'alipay',
  'wechat_pay',
  'ideal',
  'sepa_debit',
] as const;
```

### 4. å®¢æˆ·ç«¯é…ç½®

```typescript
// src/services/payment/stripe-client.ts
import { loadStripe, Stripe } from '@stripe/stripe-js';

let stripePromise: Promise<Stripe | null>;

export const getStripe = () => {
  if (!stripePromise) {
    if (!process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY) {
      throw new Error('NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY is not set');
    }
    
    stripePromise = loadStripe(process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY);
  }
  
  return stripePromise;
};

// Stripe å…ƒç´ é…ç½®
export const stripeElementsOptions = {
  appearance: {
    theme: 'stripe' as const,
    variables: {
      colorPrimary: '#0570de',
      colorBackground: '#ffffff',
      colorText: '#30313d',
      colorDanger: '#df1b41',
      fontFamily: 'Inter, system-ui, sans-serif',
      spacingUnit: '4px',
      borderRadius: '8px',
    },
  },
  locale: 'zh' as const,
};
```

## å¿«é€Ÿå¼€å§‹

### 1. åˆ›å»ºäº§å“å’Œä»·æ ¼

é¦–å…ˆåœ¨ Stripe Dashboard ä¸­åˆ›å»ºäº§å“å’Œä»·æ ¼ï¼Œæˆ–é€šè¿‡ API åˆ›å»ºï¼š

```typescript
// src/services/payment/products.ts
import { stripe } from './stripe-config';

// åˆ›å»ºäº§å“
export async function createProduct(productData: {
  name: string;
  description?: string;
  images?: string[];
  metadata?: Record<string, string>;
}) {
  const product = await stripe.products.create({
    name: productData.name,
    description: productData.description,
    images: productData.images,
    metadata: productData.metadata,
  });

  return product;
}

// åˆ›å»ºä»·æ ¼
export async function createPrice(priceData: {
  productId: string;
  unitAmount: number; // ä»¥åˆ†ä¸ºå•ä½
  currency?: string;
  recurring?: {
    interval: 'day' | 'week' | 'month' | 'year';
    intervalCount?: number;
  };
}) {
  const price = await stripe.prices.create({
    product: priceData.productId,
    unit_amount: priceData.unitAmount,
    currency: priceData.currency || 'usd',
    recurring: priceData.recurring,
  });

  return price;
}

// è·å–æ‰€æœ‰äº§å“å’Œä»·æ ¼
export async function getProductsWithPrices() {
  const products = await stripe.products.list({
    active: true,
    expand: ['data.default_price'],
  });

  const prices = await stripe.prices.list({
    active: true,
    expand: ['data.product'],
  });

  return {
    products: products.data,
    prices: prices.data,
  };
}
```

### 2. ä¸€æ¬¡æ€§æ”¯ä»˜

#### åˆ›å»ºæ”¯ä»˜ä¼šè¯ API

```typescript
// src/app/api/payment/create-checkout-session/route.ts
import { stripe, STRIPE_CONFIG } from '@/services/payment/stripe-config';
import { auth } from '@/services/userauth/auth';
import { headers } from 'next/headers';
import { NextRequest } from 'next/server';

export async function POST(req: NextRequest) {
  try {
    // éªŒè¯ç”¨æˆ·èº«ä»½
    const session = await auth.api.getSession({
      headers: headers(),
    });

    if (!session) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { 
      priceId, 
      quantity = 1, 
      metadata = {},
      successUrl,
      cancelUrl 
    } = await req.json();

    // éªŒè¯ä»·æ ¼ ID
    if (!priceId) {
      return Response.json({ error: 'Price ID is required' }, { status: 400 });
    }

    // åˆ›å»ºæˆ–è·å– Stripe å®¢æˆ·
    let customer;
    try {
      const customers = await stripe.customers.list({
        email: session.user.email,
        limit: 1,
      });

      if (customers.data.length > 0) {
        customer = customers.data[0];
      } else {
        customer = await stripe.customers.create({
          email: session.user.email,
          name: session.user.name,
          metadata: {
            userId: session.user.id,
          },
        });
      }
    } catch (error) {
      console.error('Error creating/finding customer:', error);
      return Response.json({ error: 'Customer creation failed' }, { status: 500 });
    }

    // åˆ›å»ºæ”¯ä»˜ä¼šè¯
    const checkoutSession = await stripe.checkout.sessions.create({
      customer: customer.id,
      mode: 'payment',
      payment_method_types: ['card', 'alipay', 'wechat_pay'],
      line_items: [
        {
          price: priceId,
          quantity,
        },
      ],
      success_url: successUrl || `${STRIPE_CONFIG.successUrl}?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: cancelUrl || STRIPE_CONFIG.cancelUrl,
      metadata: {
        userId: session.user.id,
        ...metadata,
      },
      // è‡ªåŠ¨ç¨è´¹è®¡ç®—
      automatic_tax: { enabled: true },
      // å…è®¸ä¿ƒé”€ç 
      allow_promotion_codes: true,
      // è´¦å•åœ°å€æ”¶é›†
      billing_address_collection: 'required',
      // è¿è¾“åœ°å€æ”¶é›†ï¼ˆå¦‚æœéœ€è¦ï¼‰
      shipping_address_collection: {
        allowed_countries: ['US', 'CA', 'GB', 'AU', 'CN'],
      },
    });

    return Response.json({ 
      sessionId: checkoutSession.id,
      url: checkoutSession.url,
    });
  } catch (error) {
    console.error('Checkout session creation error:', error);
    return Response.json(
      { error: 'Failed to create checkout session' },
      { status: 500 }
    );
  }
}
```

#### æ”¯ä»˜æŒ‰é’®ç»„ä»¶

```tsx
// src/components/payment/checkout-button.tsx
'use client';

import { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Loader2, CreditCard } from 'lucide-react';
import { toast } from 'sonner';
import { getStripe } from '@/services/payment/stripe-client';

interface CheckoutButtonProps {
  priceId: string;
  quantity?: number;
  metadata?: Record<string, string>;
  children?: React.ReactNode;
  className?: string;
  disabled?: boolean;
}

export function CheckoutButton({
  priceId,
  quantity = 1,
  metadata = {},
  children,
  className,
  disabled = false,
}: CheckoutButtonProps) {
  const [loading, setLoading] = useState(false);

  const handleCheckout = async () => {
    if (disabled || loading) return;

    setLoading(true);
    
    try {
      // åˆ›å»ºæ”¯ä»˜ä¼šè¯
      const response = await fetch('/api/payment/create-checkout-session', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          priceId,
          quantity,
          metadata,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(data.error || 'Failed to create checkout session');
      }

      // è·³è½¬åˆ° Stripe Checkout
      const stripe = await getStripe();
      if (!stripe) {
        throw new Error('Stripe failed to load');
      }

      const { error } = await stripe.redirectToCheckout({
        sessionId: data.sessionId,
      });

      if (error) {
        throw new Error(error.message);
      }
    } catch (error) {
      console.error('Checkout error:', error);
      toast.error(
        error instanceof Error ? error.message : 'æ”¯ä»˜å¤±è´¥ï¼Œè¯·é‡è¯•'
      );
    } finally {
      setLoading(false);
    }
  };

  return (
    <Button
      onClick={handleCheckout}
      disabled={disabled || loading}
      className={className}
    >
      {loading ? (
        <>
          <Loader2 className="w-4 h-4 mr-2 animate-spin" />
          å¤„ç†ä¸­...
        </>
      ) : (
        <>
          <CreditCard className="w-4 h-4 mr-2" />
          {children || 'ç«‹å³è´­ä¹°'}
        </>
      )}
    </Button>
  );
}
```

### 3. åµŒå…¥å¼æ”¯ä»˜è¡¨å•

å¯¹äºæ›´å¥½çš„ç”¨æˆ·ä½“éªŒï¼Œå¯ä»¥ä½¿ç”¨åµŒå…¥å¼æ”¯ä»˜è¡¨å•ï¼š

```tsx
// src/components/payment/embedded-checkout.tsx
'use client';

import { useState, useEffect } from 'react';
import { Elements, PaymentElement, useStripe, useElements } from '@stripe/react-stripe-js';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Loader2 } from 'lucide-react';
import { getStripe, stripeElementsOptions } from '@/services/payment/stripe-client';

interface PaymentFormProps {
  clientSecret: string;
  onSuccess?: (paymentIntent: any) => void;
  onError?: (error: string) => void;
}

function PaymentForm({ clientSecret, onSuccess, onError }: PaymentFormProps) {
  const stripe = useStripe();
  const elements = useElements();
  const [loading, setLoading] = useState(false);
  const [message, setMessage] = useState<string | null>(null);

  const handleSubmit = async (event: React.FormEvent) => {
    event.preventDefault();

    if (!stripe || !elements) {
      return;
    }

    setLoading(true);
    setMessage(null);

    const { error, paymentIntent } = await stripe.confirmPayment({
      elements,
      confirmParams: {
        return_url: `${window.location.origin}/payment/success`,
      },
      redirect: 'if_required',
    });

    if (error) {
      setMessage(error.message || 'æ”¯ä»˜å¤±è´¥');
      onError?.(error.message || 'æ”¯ä»˜å¤±è´¥');
    } else if (paymentIntent && paymentIntent.status === 'succeeded') {
      setMessage('æ”¯ä»˜æˆåŠŸï¼');
      onSuccess?.(paymentIntent);
    }

    setLoading(false);
  };

  return (
    <form onSubmit={handleSubmit} className="space-y-6">
      <PaymentElement />
      
      {message && (
        <div className={`p-3 rounded-lg text-sm ${
          message.includes('æˆåŠŸ') 
            ? 'bg-green-50 text-green-700 border border-green-200'
            : 'bg-red-50 text-red-700 border border-red-200'
        }`}>
          {message}
        </div>
      )}

      <Button
        type="submit"
        disabled={!stripe || loading}
        className="w-full"
      >
        {loading ? (
          <>
            <Loader2 className="w-4 h-4 mr-2 animate-spin" />
            å¤„ç†ä¸­...
          </>
        ) : (
          'ç¡®è®¤æ”¯ä»˜'
        )}
      </Button>
    </form>
  );
}

export function EmbeddedCheckout({ 
  amount, 
  currency = 'usd',
  metadata = {},
  onSuccess,
  onError 
}: {
  amount: number;
  currency?: string;
  metadata?: Record<string, string>;
  onSuccess?: (paymentIntent: any) => void;
  onError?: (error: string) => void;
}) {
  const [clientSecret, setClientSecret] = useState<string | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // åˆ›å»º PaymentIntent
    fetch('/api/payment/create-payment-intent', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        amount,
        currency,
        metadata,
      }),
    })
      .then((res) => res.json())
      .then((data) => {
        setClientSecret(data.clientSecret);
        setLoading(false);
      })
      .catch((error) => {
        console.error('Error creating payment intent:', error);
        onError?.('åˆ›å»ºæ”¯ä»˜å¤±è´¥');
        setLoading(false);
      });
  }, [amount, currency, metadata, onError]);

  if (loading) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardContent className="flex items-center justify-center p-6">
          <Loader2 className="w-6 h-6 animate-spin" />
          <span className="ml-2">åŠ è½½æ”¯ä»˜è¡¨å•...</span>
        </CardContent>
      </Card>
    );
  }

  if (!clientSecret) {
    return (
      <Card className="w-full max-w-md mx-auto">
        <CardContent className="p-6">
          <p className="text-red-600">æ”¯ä»˜è¡¨å•åŠ è½½å¤±è´¥</p>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card className="w-full max-w-md mx-auto">
      <CardHeader>
        <CardTitle>æ”¯ä»˜ä¿¡æ¯</CardTitle>
      </CardHeader>
      <CardContent>
        <Elements 
          stripe={getStripe()} 
          options={{
            clientSecret,
            ...stripeElementsOptions,
          }}
        >
          <PaymentForm
            clientSecret={clientSecret}
            onSuccess={onSuccess}
            onError={onError}
          />
        </Elements>
      </CardContent>
    </Card>
  );
}
```

## è®¢é˜…ç®¡ç†

### 1. åˆ›å»ºè®¢é˜…æœåŠ¡

```typescript
// src/services/payment/subscription.ts
import { stripe } from './stripe-config';
import { db } from '@/services/database/client';
import { user } from '@/services/database/schema';
import { eq } from 'drizzle-orm';

export interface SubscriptionPlan {
  id: string;
  name: string;
  description: string;
  priceId: string;
  price: number;
  currency: string;
  interval: 'month' | 'year';
  features: string[];
}

// é¢„å®šä¹‰çš„è®¢é˜…è®¡åˆ’
export const SUBSCRIPTION_PLANS: SubscriptionPlan[] = [
  {
    id: 'basic',
    name: 'åŸºç¡€ç‰ˆ',
    description: 'é€‚åˆä¸ªäººç”¨æˆ·',
    priceId: 'price_basic_monthly',
    price: 999, // $9.99
    currency: 'usd',
    interval: 'month',
    features: ['åŸºç¡€åŠŸèƒ½', '5GB å­˜å‚¨', 'é‚®ä»¶æ”¯æŒ'],
  },
  {
    id: 'pro',
    name: 'ä¸“ä¸šç‰ˆ',
    description: 'é€‚åˆå°å›¢é˜Ÿ',
    priceId: 'price_pro_monthly',
    price: 1999, // $19.99
    currency: 'usd',
    interval: 'month',
    features: ['æ‰€æœ‰åŸºç¡€åŠŸèƒ½', '50GB å­˜å‚¨', 'ä¼˜å…ˆæ”¯æŒ', 'API è®¿é—®'],
  },
  {
    id: 'enterprise',
    name: 'ä¼ä¸šç‰ˆ',
    description: 'é€‚åˆå¤§å‹ç»„ç»‡',
    priceId: 'price_enterprise_monthly',
    price: 4999, // $49.99
    currency: 'usd',
    interval: 'month',
    features: ['æ‰€æœ‰ä¸“ä¸šåŠŸèƒ½', 'æ— é™å­˜å‚¨', '24/7 æ”¯æŒ', 'è‡ªå®šä¹‰é›†æˆ'],
  },
];

// åˆ›å»ºè®¢é˜…
export async function createSubscription(
  customerId: string,
  priceId: string,
  options: {
    trialPeriodDays?: number;
    metadata?: Record<string, string>;
    coupon?: string;
  } = {}
) {
  try {
    const subscription = await stripe.subscriptions.create({
      customer: customerId,
      items: [{ price: priceId }],
      payment_behavior: 'default_incomplete',
      payment_settings: { 
        save_default_payment_method: 'on_subscription',
        payment_method_types: ['card'],
      },
      expand: ['latest_invoice.payment_intent'],
      trial_period_days: options.trialPeriodDays,
      metadata: options.metadata,
      coupon: options.coupon,
      // è‡ªåŠ¨ç¨è´¹
      automatic_tax: { enabled: true },
    });

    return {
      success: true,
      subscription,
      clientSecret: subscription.latest_invoice?.payment_intent?.client_secret,
    };
  } catch (error) {
    console.error('Create subscription error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

// æ›´æ–°è®¢é˜…
export async function updateSubscription(
  subscriptionId: string,
  updates: {
    priceId?: string;
    quantity?: number;
    metadata?: Record<string, string>;
  }
) {
  try {
    const subscription = await stripe.subscriptions.retrieve(subscriptionId);
    
    const updateData: any = {
      metadata: updates.metadata,
    };

    if (updates.priceId) {
      updateData.items = [
        {
          id: subscription.items.data[0].id,
          price: updates.priceId,
          quantity: updates.quantity || 1,
        },
      ];
      updateData.proration_behavior = 'create_prorations';
    }

    const updatedSubscription = await stripe.subscriptions.update(
      subscriptionId,
      updateData
    );

    return {
      success: true,
      subscription: updatedSubscription,
    };
  } catch (error) {
    console.error('Update subscription error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

// å–æ¶ˆè®¢é˜…
export async function cancelSubscription(
  subscriptionId: string,
  immediately: boolean = false
) {
  try {
    let subscription;
    
    if (immediately) {
      subscription = await stripe.subscriptions.cancel(subscriptionId);
    } else {
      subscription = await stripe.subscriptions.update(subscriptionId, {
        cancel_at_period_end: true,
      });
    }

    return {
      success: true,
      subscription,
    };
  } catch (error) {
    console.error('Cancel subscription error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

// è·å–ç”¨æˆ·è®¢é˜…
export async function getUserSubscription(userId: string) {
  try {
    // ä»æ•°æ®åº“è·å–ç”¨æˆ·ä¿¡æ¯
    const userData = await db
      .select()
      .from(user)
      .where(eq(user.id, userId))
      .limit(1);

    if (!userData.length) {
      return { success: false, error: 'User not found' };
    }

    // æŸ¥æ‰¾ Stripe å®¢æˆ·
    const customers = await stripe.customers.list({
      email: userData[0].email,
      limit: 1,
    });

    if (!customers.data.length) {
      return { success: true, subscription: null };
    }

    // è·å–æ´»è·ƒè®¢é˜…
    const subscriptions = await stripe.subscriptions.list({
      customer: customers.data[0].id,
      status: 'active',
      limit: 1,
    });

    return {
      success: true,
      subscription: subscriptions.data[0] || null,
      customer: customers.data[0],
    };
  } catch (error) {
    console.error('Get user subscription error:', error);
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}
```

### 2. è®¢é˜…ç®¡ç† API

```typescript
// src/app/api/payment/subscription/create/route.ts
import { createSubscription } from '@/services/payment/subscription';
import { auth } from '@/services/userauth/auth';
import { headers } from 'next/headers';

export async function POST(req: Request) {
  try {
    const session = await auth.api.getSession({
      headers: headers(),
    });

    if (!session) {
      return Response.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { priceId, trialPeriodDays, coupon } = await req.json();

    if (!priceId) {
      return Response.json({ error: 'Price ID is required' }, { status: 400 });
    }

    // åˆ›å»ºæˆ–è·å–å®¢æˆ·
    const customers = await stripe.customers.list({
      email: session.user.email,
      limit: 1,
    });

    let customer;
    if (customers.data.length > 0) {
      customer = customers.data[0];
    } else {
      customer = await stripe.customers.create({
        email: session.user.email,
        name: session.user.name,
        metadata: { userId: session.user.id },
      });
    }

    // åˆ›å»ºè®¢é˜…
    const result = await createSubscription(customer.id, priceId, {
      trialPeriodDays,
      coupon,
      metadata: { userId: session.user.id },
    });

    if (!result.success) {
      return Response.json({ error: result.error }, { status: 500 });
    }

    return Response.json({
      subscriptionId: result.subscription.id,
      clientSecret: result.clientSecret,
    });
  } catch (error) {
    console.error('Create subscription API error:', error);
    return Response.json(
      { error: 'Failed to create subscription' },
      { status: 500 }
    );
  }
}
```

### 3. è®¢é˜…ç®¡ç†ç»„ä»¶

```tsx
// src/components/payment/subscription-manager.tsx
'use client';

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { CheckCircle, XCircle, Clock, CreditCard } from 'lucide-react';
import { SUBSCRIPTION_PLANS } from '@/services/payment/subscription';
import { toast } from 'sonner';

interface SubscriptionStatus {
  subscription: any;
  customer: any;
}

export function SubscriptionManager() {
  const [status, setStatus] = useState<SubscriptionStatus | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetchSubscriptionStatus();
  }, []);

  const fetchSubscriptionStatus = async () => {
    try {
      const response = await fetch('/api/payment/subscription/status');
      const data = await response.json();
      
      if (response.ok) {
        setStatus(data);
      }
    } catch (error) {
      console.error('Failed to fetch subscription status:', error);
    } finally {
      setLoading(false);
    }
  };

  const handleCancelSubscription = async (immediately: boolean = false) => {
    if (!status?.subscription) return;

    try {
      const response = await fetch('/api/payment/subscription/cancel', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          subscriptionId: status.subscription.id,
          immediately,
        }),
      });

      if (response.ok) {
        toast.success(immediately ? 'è®¢é˜…å·²ç«‹å³å–æ¶ˆ' : 'è®¢é˜…å°†åœ¨æœŸæœ«å–æ¶ˆ');
        fetchSubscriptionStatus();
      } else {
        throw new Error('Failed to cancel subscription');
      }
    } catch (error) {
      toast.error('å–æ¶ˆè®¢é˜…å¤±è´¥');
    }
  };

  const getStatusBadge = (subscription: any) => {
    const status = subscription.status;
    const cancelAtPeriodEnd = subscription.cancel_at_period_end;

    if (status === 'active' && !cancelAtPeriodEnd) {
      return <Badge className="bg-green-100 text-green-800">æ´»è·ƒ</Badge>;
    } else if (status === 'active' && cancelAtPeriodEnd) {
      return <Badge className="bg-yellow-100 text-yellow-800">å³å°†å–æ¶ˆ</Badge>;
    } else if (status === 'trialing') {
      return <Badge className="bg-blue-100 text-blue-800">è¯•ç”¨ä¸­</Badge>;
    } else if (status === 'past_due') {
      return <Badge className="bg-red-100 text-red-800">é€¾æœŸ</Badge>;
    } else {
      return <Badge variant="secondary">{status}</Badge>;
    }
  };

  if (loading) {
    return (
      <Card>
        <CardContent className="flex items-center justify-center p-6">
          <div className="animate-spin rounded-full h-6 w-6 border-b-2 border-primary"></div>
          <span className="ml-2">åŠ è½½è®¢é˜…ä¿¡æ¯...</span>
        </CardContent>
      </Card>
    );
  }

  if (!status?.subscription) {
    return (
      <Card>
        <CardHeader>
          <CardTitle>è®¢é˜…ç®¡ç†</CardTitle>
        </CardHeader>
        <CardContent>
          <p className="text-muted-foreground mb-4">æ‚¨å½“å‰æ²¡æœ‰æ´»è·ƒçš„è®¢é˜…</p>
          <Button>
            <CreditCard className="w-4 h-4 mr-2" />
            é€‰æ‹©è®¢é˜…è®¡åˆ’
          </Button>
        </CardContent>
      </Card>
    );
  }

  const subscription = status.subscription;
  const currentPlan = SUBSCRIPTION_PLANS.find(
    plan => plan.priceId === subscription.items.data[0].price.id
  );

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center justify-between">
          è®¢é˜…ç®¡ç†
          {getStatusBadge(subscription)}
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-6">
        {/* å½“å‰è®¡åˆ’ä¿¡æ¯ */}
        <div>
          <h3 className="font-semibold mb-2">å½“å‰è®¡åˆ’</h3>
          <div className="flex items-center justify-between">
            <div>
              <p className="font-medium">{currentPlan?.name || 'æœªçŸ¥è®¡åˆ’'}</p>
              <p className="text-sm text-muted-foreground">
                ${(subscription.items.data[0].price.unit_amount / 100).toFixed(2)} / 
                {subscription.items.data[0].price.recurring?.interval}
              </p>
            </div>
          </div>
        </div>

        <Separator />

        {/* è®¡è´¹ä¿¡æ¯ */}
        <div>
          <h3 className="font-semibold mb-2">è®¡è´¹ä¿¡æ¯</h3>
          <div className="space-y-2 text-sm">
            <div className="flex justify-between">
              <span>ä¸‹æ¬¡è®¡è´¹æ—¥æœŸ:</span>
              <span>
                {new Date(subscription.current_period_end * 1000).toLocaleDateString()}
              </span>
            </div>
            <div className="flex justify-between">
              <span>è®¡è´¹å‘¨æœŸ:</span>
              <span>
                {new Date(subscription.current_period_start * 1000).toLocaleDateString()} - 
                {new Date(subscription.current_period_end * 1000).toLocaleDateString()}
              </span>
            </div>
          </div>
        </div>

        <Separator />

        {/* æ“ä½œæŒ‰é’® */}
        <div className="space-y-2">
          <Button variant="outline" className="w-full">
            æ›´æ”¹è®¡åˆ’
          </Button>
          
          {subscription.status === 'active' && !subscription.cancel_at_period_end && (
            <Button
              variant="destructive"
              className="w-full"
              onClick={() => handleCancelSubscription(false)}
            >
              å–æ¶ˆè®¢é˜…
            </Button>
          )}
          
          {subscription.cancel_at_period_end && (
            <Button
              variant="outline"
              className="w-full"
              onClick={() => {
                // é‡æ–°æ¿€æ´»è®¢é˜…çš„é€»è¾‘
              }}
            >
              é‡æ–°æ¿€æ´»è®¢é˜…
            </Button>
          )}
        </div>
      </CardContent>
    </Card>
  );
}
```

## Webhook å¤„ç†

### 1. Webhook ç«¯ç‚¹

```typescript
// src/app/api/payment/webhooks/stripe/route.ts
import { stripe } from '@/services/payment/stripe-config';
import { db } from '@/services/database/client';
import { user } from '@/services/database/schema';
import { eq } from 'drizzle-orm';
import { headers } from 'next/headers';

export async function POST(req: Request) {
  const body = await req.text();
  const signature = headers().get('stripe-signature');

  if (!signature) {
    return Response.json(
      { error: 'Missing stripe-signature header' },
      { status: 400 }
    );
  }

  let event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      process.env.STRIPE_WEBHOOK_SECRET!
    );
  } catch (err) {
    console.error('Webhook signature verification failed:', err);
    return Response.json(
      { error: 'Webhook signature verification failed' },
      { status: 400 }
    );
  }

  try {
    switch (event.type) {
      case 'payment_intent.succeeded':
        await handlePaymentIntentSucceeded(event.data.object);
        break;

      case 'payment_intent.payment_failed':
        await handlePaymentIntentFailed(event.data.object);
        break;

      case 'customer.subscription.created':
        await handleSubscriptionCreated(event.data.object);
        break;

      case 'customer.subscription.updated':
        await handleSubscriptionUpdated(event.data.object);
        break;

      case 'customer.subscription.deleted':
        await handleSubscriptionDeleted(event.data.object);
        break;

      case 'invoice.payment_succeeded':
        await handleInvoicePaymentSucceeded(event.data.object);
        break;

      case 'invoice.payment_failed':
        await handleInvoicePaymentFailed(event.data.object);
        break;

      default:
        console.log(`Unhandled event type: ${event.type}`);
    }

    return Response.json({ received: true });
  } catch (error) {
    console.error('Webhook handler error:', error);
    return Response.json(
      { error: 'Webhook handler failed' },
      { status: 500 }
    );
  }
}

// å¤„ç†æ”¯ä»˜æˆåŠŸ
async function handlePaymentIntentSucceeded(paymentIntent: any) {
  console.log('Payment succeeded:', paymentIntent.id);
  
  // æ›´æ–°è®¢å•çŠ¶æ€
  // å‘é€ç¡®è®¤é‚®ä»¶
  // è®°å½•æ”¯ä»˜æ—¥å¿—
}

// å¤„ç†æ”¯ä»˜å¤±è´¥
async function handlePaymentIntentFailed(paymentIntent: any) {
  console.log('Payment failed:', paymentIntent.id);
  
  // é€šçŸ¥ç”¨æˆ·æ”¯ä»˜å¤±è´¥
  // è®°å½•å¤±è´¥åŸå› 
}

// å¤„ç†è®¢é˜…åˆ›å»º
async function handleSubscriptionCreated(subscription: any) {
  console.log('Subscription created:', subscription.id);
  
  const customerId = subscription.customer;
  const customer = await stripe.customers.retrieve(customerId);
  
  if (customer && !customer.deleted && customer.metadata?.userId) {
    // æ›´æ–°ç”¨æˆ·è®¢é˜…çŠ¶æ€
    await updateUserSubscriptionStatus(
      customer.metadata.userId,
      subscription.status,
      subscription.id
    );
  }
}

// å¤„ç†è®¢é˜…æ›´æ–°
async function handleSubscriptionUpdated(subscription: any) {
  console.log('Subscription updated:', subscription.id);
  
  const customerId = subscription.customer;
  const customer = await stripe.customers.retrieve(customerId);
  
  if (customer && !customer.deleted && customer.metadata?.userId) {
    await updateUserSubscriptionStatus(
      customer.metadata.userId,
      subscription.status,
      subscription.id
    );
  }
}

// å¤„ç†è®¢é˜…åˆ é™¤
async function handleSubscriptionDeleted(subscription: any) {
  console.log('Subscription deleted:', subscription.id);
  
  const customerId = subscription.customer;
  const customer = await stripe.customers.retrieve(customerId);
  
  if (customer && !customer.deleted && customer.metadata?.userId) {
    await updateUserSubscriptionStatus(
      customer.metadata.userId,
      'canceled',
      null
    );
  }
}

// å¤„ç†å‘ç¥¨æ”¯ä»˜æˆåŠŸ
async function handleInvoicePaymentSucceeded(invoice: any) {
  console.log('Invoice payment succeeded:', invoice.id);
  
  // è®°å½•æ”¯ä»˜å†å²
  // æ›´æ–°è´¦æˆ·ä½™é¢
}

// å¤„ç†å‘ç¥¨æ”¯ä»˜å¤±è´¥
async function handleInvoicePaymentFailed(invoice: any) {
  console.log('Invoice payment failed:', invoice.id);
  
  // é€šçŸ¥ç”¨æˆ·æ”¯ä»˜å¤±è´¥
  // å¯èƒ½éœ€è¦æš‚åœæœåŠ¡
}

// æ›´æ–°ç”¨æˆ·è®¢é˜…çŠ¶æ€
async function updateUserSubscriptionStatus(
  userId: string,
  status: string,
  subscriptionId: string | null
) {
  try {
    // è¿™é‡Œåº”è¯¥æ ¹æ®ä½ çš„æ•°æ®åº“ç»“æ„æ¥æ›´æ–°ç”¨æˆ·è®¢é˜…çŠ¶æ€
    // ç¤ºä¾‹ï¼šå‡è®¾ç”¨æˆ·è¡¨æœ‰è®¢é˜…ç›¸å…³å­—æ®µ
    /*
    await db
      .update(user)
      .set({
        subscriptionStatus: status,
        subscriptionId: subscriptionId,
        updatedAt: new Date(),
      })
      .where(eq(user.id, userId));
    */
    
    console.log(`Updated user ${userId} subscription status to ${status}`);
  } catch (error) {
    console.error('Failed to update user subscription status:', error);
  }
}
```

### 2. Webhook å®‰å…¨éªŒè¯

```typescript
// src/services/payment/webhook-security.ts
import crypto from 'crypto';

export function verifyWebhookSignature(
  payload: string,
  signature: string,
  secret: string
): boolean {
  const elements = signature.split(',');
  const signatureElements: Record<string, string> = {};

  for (const element of elements) {
    const [key, value] = element.split('=');
    signatureElements[key] = value;
  }

  const timestamp = signatureElements.t;
  const signatures = [
    signatureElements.v1,
    signatureElements.v0,
  ].filter(Boolean);

  if (!timestamp || signatures.length === 0) {
    return false;
  }

  // æ£€æŸ¥æ—¶é—´æˆ³ï¼ˆé˜²æ­¢é‡æ”¾æ”»å‡»ï¼‰
  const timestampNumber = parseInt(timestamp, 10);
  const currentTime = Math.floor(Date.now() / 1000);
  const tolerance = 300; // 5åˆ†é’Ÿå®¹å·®

  if (Math.abs(currentTime - timestampNumber) > tolerance) {
    return false;
  }

  // éªŒè¯ç­¾å
  const payloadForSignature = `${timestamp}.${payload}`;
  const expectedSignature = crypto
    .createHmac('sha256', secret)
    .update(payloadForSignature)
    .digest('hex');

  return signatures.some(signature => 
    crypto.timingSafeEqual(
      Buffer.from(signature, 'hex'),
      Buffer.from(expectedSignature, 'hex')
    )
  );
}
```

## å®‰å…¨å’Œæœ€ä½³å®è·µ

### 1. ç¯å¢ƒå˜é‡å®‰å…¨

```typescript
// src/services/payment/security.ts

// éªŒè¯å¿…éœ€çš„ç¯å¢ƒå˜é‡
export function validateStripeConfig() {
  const requiredVars = [
    'STRIPE_SECRET_KEY',
    'NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY',
    'STRIPE_WEBHOOK_SECRET',
  ];

  const missing = requiredVars.filter(
    varName => !process.env[varName]
  );

  if (missing.length > 0) {
    throw new Error(
      `Missing required Stripe environment variables: ${missing.join(', ')}`
    );
  }

  // éªŒè¯å¯†é’¥æ ¼å¼
  const secretKey = process.env.STRIPE_SECRET_KEY!;
  const publishableKey = process.env.NEXT_PUBLIC_STRIPE_PUBLISHABLE_KEY!;

  if (!secretKey.startsWith('sk_')) {
    throw new Error('Invalid Stripe secret key format');
  }

  if (!publishableKey.startsWith('pk_')) {
    throw new Error('Invalid Stripe publishable key format');
  }

  // æ£€æŸ¥æ˜¯å¦åœ¨ç”Ÿäº§ç¯å¢ƒä½¿ç”¨æµ‹è¯•å¯†é’¥
  if (process.env.NODE_ENV === 'production') {
    if (secretKey.includes('test') || publishableKey.includes('test')) {
      console.warn('Warning: Using test keys in production environment');
    }
  }
}

// åˆå§‹åŒ–æ—¶éªŒè¯é…ç½®
validateStripeConfig();
```

### 2. é”™è¯¯å¤„ç†å’Œæ—¥å¿—

```typescript
// src/services/payment/error-handling.ts
export class PaymentError extends Error {
  constructor(
    message: string,
    public code: string,
    public statusCode: number = 400
  ) {
    super(message);
    this.name = 'PaymentError';
  }
}

export function handleStripeError(error: any): PaymentError {
  if (error.type) {
    switch (error.type) {
      case 'StripeCardError':
        return new PaymentError(
          'æ‚¨çš„é“¶è¡Œå¡è¢«æ‹’ç»ï¼Œè¯·å°è¯•å…¶ä»–æ”¯ä»˜æ–¹å¼',
          'card_declined',
          400
        );
      case 'StripeRateLimitError':
        return new PaymentError(
          'è¯·æ±‚è¿‡äºé¢‘ç¹ï¼Œè¯·ç¨åé‡è¯•',
          'rate_limit',
          429
        );
      case 'StripeInvalidRequestError':
        return new PaymentError(
          'æ”¯ä»˜è¯·æ±‚æ— æ•ˆ',
          'invalid_request',
          400
        );
      case 'StripeAPIError':
        return new PaymentError(
          'æ”¯ä»˜æœåŠ¡æš‚æ—¶ä¸å¯ç”¨ï¼Œè¯·ç¨åé‡è¯•',
          'api_error',
          500
        );
      case 'StripeConnectionError':
        return new PaymentError(
          'ç½‘ç»œè¿æ¥é”™è¯¯ï¼Œè¯·æ£€æŸ¥ç½‘ç»œåé‡è¯•',
          'connection_error',
          500
        );
      case 'StripeAuthenticationError':
        return new PaymentError(
          'æ”¯ä»˜è®¤è¯å¤±è´¥',
          'authentication_error',
          401
        );
      default:
        return new PaymentError(
          'æ”¯ä»˜å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•',
          'unknown_error',
          500
        );
    }
  }

  return new PaymentError(
    error.message || 'æœªçŸ¥é”™è¯¯',
    'unknown_error',
    500
  );
}

// æ”¯ä»˜æ—¥å¿—è®°å½•
export function logPaymentEvent(
  event: string,
  data: any,
  userId?: string
) {
  const logData = {
    timestamp: new Date().toISOString(),
    event,
    userId,
    data: JSON.stringify(data),
  };

  // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œåº”è¯¥ä½¿ç”¨ä¸“ä¸šçš„æ—¥å¿—æœåŠ¡
  console.log('Payment Event:', logData);
  
  // å¯ä»¥é›†æˆåˆ°æ—¥å¿—æœåŠ¡ï¼Œå¦‚ Winston, Pino ç­‰
}
```

### 3. æµ‹è¯•å’Œè°ƒè¯•

```typescript
// src/services/payment/testing.ts

// æµ‹è¯•ç”¨çš„ä¿¡ç”¨å¡å·ç 
export const TEST_CARDS = {
  visa: '4242424242424242',
  visaDebit: '4000056655665556',
  mastercard: '5555555555554444',
  amex: '378282246310005',
  declined: '4000000000000002',
  insufficientFunds: '4000000000009995',
  lostCard: '4000000000009987',
  stolenCard: '4000000000009979',
};

// æµ‹è¯•æ¨¡å¼æ£€æŸ¥
export function isTestMode(): boolean {
  return process.env.STRIPE_SECRET_KEY?.includes('test') || false;
}

// åˆ›å»ºæµ‹è¯•äº§å“å’Œä»·æ ¼
export async function createTestProducts() {
  if (!isTestMode()) {
    throw new Error('Test products can only be created in test mode');
  }

  const products = await Promise.all([
    stripe.products.create({
      name: 'åŸºç¡€ç‰ˆè®¢é˜…',
      description: 'æµ‹è¯•ç”¨åŸºç¡€ç‰ˆè®¢é˜…',
    }),
    stripe.products.create({
      name: 'ä¸“ä¸šç‰ˆè®¢é˜…',
      description: 'æµ‹è¯•ç”¨ä¸“ä¸šç‰ˆè®¢é˜…',
    }),
  ]);

  const prices = await Promise.all([
    stripe.prices.create({
      product: products[0].id,
      unit_amount: 999,
      currency: 'usd',
      recurring: { interval: 'month' },
    }),
    stripe.prices.create({
      product: products[1].id,
      unit_amount: 1999,
      currency: 'usd',
      recurring: { interval: 'month' },
    }),
  ]);

  return { products, prices };
}
```

## æ•…éšœæ’é™¤

### å¸¸è§é—®é¢˜

1. **Webhook éªŒè¯å¤±è´¥**
   - æ£€æŸ¥ `STRIPE_WEBHOOK_SECRET` é…ç½®
   - ç¡®è®¤ Webhook ç«¯ç‚¹ URL æ­£ç¡®
   - éªŒè¯è¯·æ±‚ä½“æœªè¢«ä¿®æ”¹

2. **æ”¯ä»˜å¤±è´¥**
   - æ£€æŸ¥æµ‹è¯•å¡å·æ˜¯å¦æ­£ç¡®
   - ç¡®è®¤é‡‘é¢å’Œè´§å¸è®¾ç½®
   - æŸ¥çœ‹ Stripe Dashboard é”™è¯¯æ—¥å¿—

3. **è®¢é˜…é—®é¢˜**
   - éªŒè¯ä»·æ ¼ ID æ˜¯å¦å­˜åœ¨
   - æ£€æŸ¥å®¢æˆ·æ˜¯å¦å·²æœ‰æ´»è·ƒè®¢é˜…
   - ç¡®è®¤æ”¯ä»˜æ–¹å¼å·²ä¿å­˜

### è°ƒè¯•æŠ€å·§

```typescript
// å¯ç”¨è¯¦ç»†æ—¥å¿—
if (process.env.NODE_ENV === 'development') {
  stripe.setAppInfo({
    name: 'vibetake',
    version: '1.0.0',
    url: 'https://your-app.com',
  });
}

// ç›‘æ§ API è°ƒç”¨
const originalRequest = stripe._request;
stripe._request = function(method, path, data, auth, options, callback) {
  console.log(`Stripe API: ${method} ${path}`, data);
  return originalRequest.call(this, method, path, data, auth, options, callback);
};
```

é€šè¿‡æœ¬æ–‡æ¡£ï¼Œä½ åº”è¯¥èƒ½å¤Ÿåœ¨ vibetake ä¸­å®Œæ•´åœ°é›†æˆå’Œä½¿ç”¨ Stripe æ”¯ä»˜ç³»ç»Ÿã€‚è®°ä½å§‹ç»ˆåœ¨æµ‹è¯•ç¯å¢ƒä¸­éªŒè¯æ‰€æœ‰åŠŸèƒ½ï¼Œå¹¶ç¡®ä¿éµå¾ª Stripe çš„æœ€ä½³å®è·µå’Œå®‰å…¨æŒ‡å—ã€‚å¦‚éœ€æ›´å¤šä¿¡æ¯ï¼Œè¯·å‚è€ƒ [Stripe å®˜æ–¹æ–‡æ¡£](https://stripe.com/docs)ã€‚